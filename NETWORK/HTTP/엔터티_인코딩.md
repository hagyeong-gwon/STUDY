엔터티와 인코딩
=

HTTP 메시지를 운송 시스템의 컨테이너라 한다면, HTTP 엔터티는 메시지의 실질적인 화물이다.

![image](https://user-images.githubusercontent.com/70934609/113518195-c3ba7100-95bf-11eb-852f-1c085912ea60.png)

### 엔터티 헤더

- Content-Type 엔터티에 의해 전달된 객체의 종류

- Content-Length 전달되는 메시지의 길이나 크기
- Content-Language 전달되는 객체와 가장 잘 대응되는 자연어
- Content-Encoding 객체 데이터에 대해 행해진 압축과 같은 변형
- Content-Location 요청 시점을 기준으로, 객체의 또 다른 위치
- Content-Range 부분 엔터티라면 전체에서 어느 부분에 해당하는지 정의
- Content-MD5 엔터티 본문의 컨텐츠에 대한 체크섬
- Last-Modified 서버에서 이 컨텐츠가 생성, 수정된 날
- Expires 이 엔터티 데이터가 더 이상 신선하지 않은 것으로 간주되기 시작하는 날짜와 시각
- Allow 이 리소스에 대해 어떤 요청 메서드가 허용되는지

### 엔터티 본문

엔터티 본문은 가공되지 않은 데이터만을 담고 있다. 다른 정보들은 모두 헤더에 담겨 있다. 따라서 엔터티 헤더는 그 데이터의 의미를 설명할 필요가 있다.

엔터티 본문은 헤더 필드의 끝을 의미하는 빈 CRLF 줄 바로 다음부터 시작한다. 16진수 값들은 텍스트와 이미지 엔터티의 정확한 내용을 알려준다.

### Content-Length: 엔터티의 길이

Content-Length 헤더는 메시지의 엔터티 본문의 크기를 바이트 단위로 나타낸다. 어떻게 인코딩 되었든 상관없이 크기를 표현할 수 있다.

엔터티 본문을 포함한 메시지에서는 필수적으로 있어야 한다. 서버 충돌로 인한 메시지 잘림 검출과 지속 커넥션을 공유하는 메시지를 분할하고자 할 때 필요하기 때문이다.


*메시지 잘림은 캐싱 프록시 서버에서 특히 취약하기 때문에 캐싱 프록시 서버는 명시적으로 Content-Length 헤더를 갖고 있지 않은 HTTP 본문은 캐시하지 않는다.*

### Content-Length와 지속커넥션

Content-Length는 지속 커넥션을 위해 필수다. 이는 클라이언트에게 메시지 하나가 어디서 끝나고, 다음 시작은 어디인지 알려준다.

커넥션은 지속적이기에, 클라이언트가 커넥션이 닫힌 위치를 근거로 메시지의 끝을 인식하는 것은 불가능하다. 따라서 HTTP 애플리케이션은 엔터티 본문의 길이와 끝을 인식하고자 Content-Length 헤더를 활용한다.

### 콘텐츠 인코딩

HTTP는 보안을 강화하거나 압축을 통해 공간을 절약할 수 있도록할때 엔터티 본문을 인코딩할수 있게 해도록 해준다.

이때 Content-Length 헤더는 인코딩 되지 않은 원본의 길이가 아닌 인코딩 된 본문의 길이를 바이트 단위로 정의하게 된다.

미디어 타입과 Charset
-


Content-Type 헤더는 본문의 MIME 타입을 기술하게 된다.

MIME 타입은 전달되는 매체의 기저형식(HTML, 워드,MPEG..ETC) 의 표준화된 이름이다.
클라이언트 애플리케이션은 콘텐츠를 적절히 해독하고 처리하기 위해 MIME 타입을 이용하게 된다.


MIME 타입은 주 미디어 타입(텍스트,이미지,오디오) 로 시작해서 뒤이어 빗금 (/), 그리고 미디어 타입을 더 구체적으로 서술하는 부타입(subtype) 으로 구성된다.

콘텐츠 인코딩
-

![image](https://user-images.githubusercontent.com/70934609/113518408-26f8d300-95c1-11eb-9366-a45ccd8d771b.png)

1. 웹서버가 원본 Content-Type 과 Content-Length 헤더를 수반한 원본 응답 메시지를 생성한다.
2. 콘텐츠 인코딩 서버가 인코딩된 메시지를 생성한다. 인코딩된 메시지는 Content-Type은 같지만 Content-Length 는 다르다. 콘텐츠 인코딩 서버는 Content-Encoding 헤더를 
3. 인코딩된 메시지에 추가해 수신측에서 디코딩할수 있도록 한다.
수신 측에서 디코딩해 원본을 얻는다.

### Accept-Encoding 헤더

클라이언트는 자신이 지원하는 인코딩의 목록을 Accept-Encoding 헤더를 통해 전달한다.

Q(quality) 값을 매개변수로 더해 선호도를 나타낼수도 있다.

```
Accept-Encoding: compress,gzip
Accept-Encoding: *
Accept-Encoding: compress;q=0.5, gzip;1.0
```

범위 요청
-

HTTP 클라이언트는 받다가 실패한 엔터티를 일부 혹은 범위로 요청함으로써 다운로드를 중단된 시점에서 재개할 수 있다.

이 range 헤더는 peer to peer 파일 공유 클라이언트가 멀티미디어 파일의 다른 부분을 다른 피어로부터 동시에 다운로드 받을때 널리 사용된다.
모든 서버가 범위 요청을 받아 들일수 있는 것은 아니지만 서버가 응답으로 Accept-Range 헤더를 포함시키는 방법으로 알려줄수 있다.
ex) Accept-Ranges: bytes

![image](https://user-images.githubusercontent.com/70934609/113518626-7b508280-95c2-11eb-94c7-e480692e4dd3.png)
