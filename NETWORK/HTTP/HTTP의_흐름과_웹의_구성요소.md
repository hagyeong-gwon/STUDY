# 1. HTTP의 흐름

**TCP란 무엇일까?**

HTTP는 애플리케이션 계층 프로토콜이다. HTTP는 네트워크 통신의 핵심적인 세부사항에 대해서 신경 쓰지 않는다. 대신 대중적이고 신뢰성 있는 인터넷 프로토콜인 **TCP/IP**에게 맡긴다. 

**TCP/IP**란 TCP와 IP가 층을 이루는, 패킷 교환 네트워크 프로토콜의 집합이다.
<br><br>

- 서버의 단순한 HTML 리소스를 보여주기 위한 흐름이다.

1. 웹브라우저는 서버의 URL에서 호스트 명을 추출한다. 
2. 웹브라우저는 서버의 호스트 명을 IP로 변환한다. 
3. 웹브라우저는 URL에서 포트번호를 추출한다.
4. 웹브라우저는 웹 서버와 TCP 커넷션을 맺는다.
5. 웹브라우저는 서버에 HTTP 요청을 보낸다.
6. 서버는 웹브라우저에 HTTP 응답을 돌려준다.
7. 커넥션이 닫히면, 웹브라우저는 문서를 보여준다.

<br>
<br><br>

*여기서 잠깐! 서버의 IP 주소와 포트번호는 어떻게 알아낼 수 있을까?*

```
http://207.200.83.29:80/index.html
http://www.netscape.com:80/index.html
http://www.netscape.com/index.html
```

정답은 URL을 이용한다!!

------------------------------
프로토콜 버전
---

HTTP/0.9

    이 프로토콜은 심각한 디자인 결함이 다수 있고 구식 클라이언트와만 같이 사용할 수 있다. 
    오직 GET 메서드만 지원하고, 멀티미디어 콘텐츠에 대한 MIME타입이나, HTTP 헤더, 버전 번호는 지원하지 않는다. 
    HTTP/0.9는 원래 간단한 HTML 객체를 받아오기 위해 만들어진 것이기 때문에 금방 1.0으로 교체되었다.


HTTP/1.0

    처음으로 널리 쓰이기 시작한 HTTP 버전이다. 
    HTTP/1.0은 버전 번호, HTTP 헤더, 추가 메서드, 멀티 미디어 객체 처리를 추가했다. 
    하지만 이는 결코 잘 정의된 명세가 아니고 상업적, 학술적으로 급성장하던 시기에 만들어진, 잘 동작하는 용례들의 모응에 가깝다.

HTTP/1.0+    

    월드 와이드 웹이 급격히 팽창하고 상업적으로도 성공하면서 여러 유명 웹클라이언트와 서버들은 그에 따른 요구를 만족시키기 위해 발 빠르게 HTTP에 기능을 추가해갔다. 
    오래 지속되는 keep-alive 커넥션, 가상 호스팅 지원, 프락시 연결 지원을 포함해 많은 기능이 공식적이진 않지만 사실상의 표준으로  HTTP에 추가되었다. 
    (따라서 1.0+은 규격외에 확장된 버전이다.)

HTTP/1.1

    HTTP 설계의 구조적 결함 교정, 두드러진 성능 최적화, 잘못된 기능제거에 집중했다. 
    뿐만 아니라 1.1은 더 복잡해진 웹 애플리케이션과 배포를 지원한다.

HTTP/2.0

    HTTP/1.1 성능 문제를 개선하기 위해 구글의 SPDY 프로토콜을 기반으로 설계된 프로토콜이다. 
    1.1은 기본적으로 하나의 연결당 하나의 요청을 처리하도록 설계되있으며, 
    그렇기 때문에 동시 전송이 불가능하고 요청과 응답이 순차적으로 이루어져 웹의 지원을 처리하기에 대기 시간이 길어지게 되었다. 


    HTTP/2.0의 대표적인 특징들로는 
    
    HTTP Header Data Compression (HTTP 헤더 데이터 압축) 이전 Header의 내용과 중복되는 필드를 재전송 하지 않도록 하여, 데이터를 절약한다.

    HTTP 1.x의 HOL(Head-of-Line) Blocking 문제 해결

    HTTP 1.1 에서 하나의 연결당 하나의요청을 처리하는 문제를 개선할 수 있는 기법 중 파이프라이닝(pipelining)이 존재하는데 
    이것은 하나의 연결을 통해서 다수개의 파일을 요청/응답 받을수 있는 기법을 의미한다.
    해당 기법을 통해서 어느 정도의 향상을 노릴수 있으나 큰 문제는 HOL 블록(Head-of-line block)이 있다.

- HTTP Header Data Compression

![image](https://user-images.githubusercontent.com/70934609/104850818-a668f580-5934-11eb-9064-483feb33a8d9.png)


- 1.x의 HOL(Head-of-Line) Blocking

![image](https://user-images.githubusercontent.com/70934609/104850875-0364ab80-5935-11eb-816f-f4b79bc4745d.png)

**HOL(Head-of-Line) Blocking: 컴퓨터 네트워킹에서 패킷 대기열이 존재 할 때, 앞선(Head) 패킷이 지연될 때 발생하는 성능 저하 현상**

HTTP/3.0

    TTP/3는 HTTP(Hypertext Transfer Protocol)의 세 번째 메이저 버전으로, 
    기존의 HTTP/1, HTTP/2와는 다르게 UDP 기반의 프로토콜인 QUIC을 사용하여 통신하는 프로토콜이다. 
    HTTP/3와 기존 HTTP 들과 가장 큰 차이점이라면 TCP가 아닌 UDP 기반의 통신을 한다는 것이다.

    즉, HTTP/3는 QUIC이라는 프로토콜 위에서 돌아가는 HTTP인 것이다. 
    QUIC은 Quick UDP Internet Connection의 약자로, 말 그대로 UDP를 사용하여 인터넷 연결을 하는 프로토콜이다.

**여기서 잠깐!! 왜 TCP를 쓰지 않고 UDP를 쓴 것일까?**


1. 3 Way Handshake

![image](https://user-images.githubusercontent.com/70934609/104851277-70794080-5937-11eb-8177-3f1f8355dbd2.png)

HTTP/1은 하나의 TCP 연결에 하나의 요청만 처리하고 연결을 끊어버렸기 때문에 매 요청마다 이 번거로운 핸드쉐이크를 거쳐야 했다!

2. HOLB(Head of line Blocking)

TCP를 사용한 통신에서 패킷은 무조건 정확한 순서대로 처리되어야 한다. 

패킷이 처리되는 순서 또한 정해져있으므로 이전에 받은 패킷을 파싱하기 전까지는 다음 패킷을 처리할 수도 없다. 이렇게 패킷이 중간에 유실되거나 수신 측의 패킷 파싱 속도가 느리다면 통신에 병목이 발생하게 되는 현상을 **HOLB**라고 부르는 것이다. 이건 TCP 자체의 문제이므로 HTTP/1 뿐만 아니라 HTTP/2도 가지고 있는 문제이다.

### HTTP/3가 UDP를 사용함으로써 기존 프로토콜보다 나아진 점

1. 연결 설정 시 레이턴시 감소

![image](https://user-images.githubusercontent.com/70934609/104851379-fb5a3b00-5937-11eb-8940-5a94267f73ff.png)

2. 클라이언트의 IP가 바뀌어도 연결이 유지됨

QUIC은 Connection ID를 사용하여 서버와 연결을 생성한다. Connection ID는 랜덤한 값일 뿐, 클라이언트의 IP와는 전혀 무관한 데이터이기 때문에 클라이언트의 IP가 변경되더라도 기존의 연결을 계속 유지할 수 있다.

# 1. 웹의 구성요소

1. 프락시

    프락시는 클라이언트와 서버 사이에 위치하여, 클라이언트의 모든 HTTP 요청을 방아 서버에 전달한다. 주로 보안을 위해 사용된다. 즉, 모든 웹 트래픽 흐름 속에서 신뢰할 만한 중개자 역할을 한다.


2. 캐시

    웹캐시와 캐시 프락시는 자신을 거쳐 가는 문서들 중 자주 찾는 것의 사본을 저장해 두는, 특별한 종류의 HTTP 프락시 서버이다. 다음번에 클라이언트가 같은 문서를 요청하면 그 캐시가 갖고 있는 사본을 받을 수 있다.


3. 게이트웨이
    
    게이트웨이는 다른 서버들의 중개자로 동작하는 특별한 서버이다. 주로 HTTP 트래픽을 다른 프로토콜로 변환하기 위해 사용된다. HTTP/FTP 게이트웨이는 FTP URL에 대한 HTTP 요청을 받아들인 뒤, FTP 프로토콜을 이용해 문서를 가져온다. 받아온 문서는 HTTP 메시지에 담겨 클라이언트에게 보낸다. 


4. 터널

    두 커넥션 사이에서 raw 데이터를 열어보지 않고 그대로 전달해주는 HTTP 애플리케이션이다. HTTP 터널은 주로 비 HTTP 데이터를 하나이상의 HTTP 연결을 통해 그대로 전송해주기 위해 사용된다.



## 참조

https://evan-moon.github.io/2019/10/08/what-is-http3/

HTTP 완벽 가이드 (책)