기본 인증
=

모든 정보나 업무가 공용은 아니기 때문에, 허가돈 사람만이 데이터에 접근하고 업무를 처리할 수 있어야 한다.

그러기 위해서는 서버가 사용자가 누구인지 식별할 수 있어야 한다. 서버가 사용자가 누구인지 알면, 그 사용자가 어떤 작업이나 리소스에 접근할 수 있는지 결정할 수 있다.


인증
-

###  HTTP의 인증 요구/응답 프레임워크

HTTP는 사용자 인증을 하는 데 사용하는 자체 인증요구/응답 프레임워크를 제공한다.

![image](https://user-images.githubusercontent.com/70934609/111916405-1ffc9b80-8abe-11eb-8e9f-170dda556b24.png)

1. 웹 애플리케이션이 HTTP 요청 메시지를 받는다.
2. 서버는 요청을 처리하는 대신 사용자가 누군인지 식별하기 위해 비밀번호 같은 개인 정보를 요구하는 인증 요구로 응답한다.
3. 인증 요구를 받은 클라이언트는 사용자에게 인증 정보를 물어 본다. 사용자는 자신의 인증 정보를 추가해 다시 요청을 보낸다.
4. 서버는 인증 정보가 맞지 않다면 다시 인증요구를 보내거나 에러를 반환한다. 인증 정보가 맞다면 문제없이 처리가 완료된다.

### 인증 프로토콜과 헤더

HTTP 인증요구/응답 과정 중 2~4에는 인증에 관련된 헤더가 추가된 요청/응답 메시지가 전송된다. 이 헤더들의 형식과 내용은 인증 프로토콜에 따라 달라지며 HTTP는 인증 프로토콜에 맞추어 고쳐 쓰고 확장할 수 있는 프레임워크를 제공한다.


- 서버의 인증 요구

서버가 인증을 요구할 때는 WWW-Authenticate 헤더를 포함한 401 Unauthorized 응답을 반환한다. 헤더의 문법은 다음과 같다.

```
WWW-Authenticate: <type> realm=<realm>
```

- 클라이언트의 인증 요청

응답을 받은 클라이언트는 인코딩된 비밀번호와 그 외 인증 파라미터들을 Authorization 헤더에 담아서 요청을 다시 보낸다.

```
Authorization: <type> <credentials>
```

### 기본 인증

기본 인증은 가장 잘 알려진 HTTP 인증 규약이다.

1. Base-64 사용자 이름/비밀번호 인코딩

HTTP 기본 인증은 사용자 이름과 비밀번호를 콜론(:)으로 이어 붙이고, base-64 인코딩 메서드를 사용해 인코딩 한다. 인코딩한 값을 Authorization 헤더에 담아서 요청을 보낸다.

```
Base-64

Base-64 인코딩은 바이너리, 텍스트, 국제 문자 데이터 등의 문자열을 전송 가능한 문자인 알파벳으로 변환하기 위해 발명됐다. 전송 중에 원본 문자열이 변질될 걱정 없이 원격에서 디코딩할 수 있다.
```

2. 프락시 인증

어떤 회사는 사용자들이 원 서버에 접근하기 전에 프락시 서버를 거치게 하여 사용자를 인증한다. 프락시 서버에서 접근 정책을 중앙 관리 할 수 있기 때문에, 회사 리소스 전체에 대해 통합적인 접근 제어를 하기 위해서 프락시 서버를 사용하면 좋다.

프락시 인증은 웹 서버의 인증과 헤더 이름과 상태 코드만 다르고 절차는 같다.


| 웹 서버 | 프락시 서버 |
|--|:--:|
| 비인증 상태 코드 : 401 |	비인증 상태 코드 : 407 |
| WWW-Authenticate	| Proxy-Authenticate |
| Authorization	| Proxy-Authorization |
| Authentication-Info | Proxy-Authentication-Info |

기본 인증의 보안 결함
-

1. 인코딩과 디코딩이 쉽다

기본 인증은 사용자 이름과 비밀번호를 쉽게 디코딩할 수 있는 형식으로 네트워크에 전송한다. 사실상 비밀번호 그대로 보내는 것과 다름이 없다. 이를 방지하기 위해서는 모든 HTTP 트랜잭션을 SSL 암호화 채널을 통해 보내거나, 보안이 더 강화된 다이제스트 인증 같은 프로토콜을 사용하는 것이 좋다.

2. 재전송 공격

보안 비밀번호가 디코딩하기에 더 복잡한 방식으로 인코딩되어 있다고 하더라도, 여전히 제 3자가 중간에 가로챈 뒤 그대로 원 서버에 보내서 인증에 성공하고 서버에 접근할 수 있다. 기본 인증은 이러한 재전송 공격을 예방하기 위한 어떤 일도 하지 않는다.

3. 동일한 사용자 이름과 비밀번호

사용자들은 여러 사이트에 동일한 사용자 이름과 비밀번호를 사용하기 마련이다. 때문에 보안이 중요하지 않은 애플리케이션이라고 하더라도 사용자의 정보가 노출되는 것은 위험하다.

4. 기존 의도와 다른 요청

메시지의 인증 헤더를 수정하지는 않지만, 그 외 다른 부분을 수정해서 트랜잭션의 본래 의도를 바꿔버리는 프락시나 중개자가 중간에
 개입하는 경우, 기본 인증은 정상적인 동작을 하지 않을 수 있다.

5. 가짜 서버

기본 인증은 가짜 서버에 취약하다. 사용자는 가짜 서버나 게이트를 검증된 서버로 착각할 수 있다. 공격자는 사용자에게 비밀번호를 요청하고 그것을 나중에 사용할 목적으로 저장한 다음 에러가 난 척을 할 수 있다.

종합해보면, 기본 인증은 다른 사람들이 보지 않기를 원하기는 하지만, 보더라도 치명적이지 않은 경우에 유용하다고 할 수 있다.



다이제스트 인증
=

기본 인증은 편리하고 유연하지만, 전혀 안전하지 않다.

1. 비밀번호를 절대로 네트워크를 통해 평문으로 전송하지 않는다.

2. 인증 체결을 가로채서 재현하려는 악의적인 사람들을 차단한다.
3. 구현하기에 따라서, 메시지 내용 위조를 막는 것도 가능하다.
4. 그 외 몇몇 잘 알려진 형태의 공격을 막는다

*위와 같은 개선점들이 있긴하지만, 다이제스트 인증 역시도 요청과 응답의 나머지 부분에 대해서는 누군가가 엿보는 것이 가능하므로, TLS나 HTTP가 더 안전한 프로토콜이다.*

![image](https://user-images.githubusercontent.com/70934609/111917614-4c1b1b00-8ac4-11eb-9678-4ead1fe147ee.png)


- 단방향 요약

요약은 정보 본문의 압축이고 여기서도 압축의 개념이다.

요약은 단방향 함수로 동작한다.

단방향 알고리즘은 암호화는 수행하지만 절대로 복호화가 불가능한 알고리즘을 뜻한다.
대표적인 요약 함수는 MD5이고, 임의의 바이트 배열을 원래 길이와 상관없이 128비트 요약으로 변환합니다.(32글자의 16진수 문자로 표현됨)
요약 함수는 보통 암호 체크섬으로 불리며 단방향 해시함수이거나 지문함수이다

- 재전송 방지를 위한 난스 사용 nonce

요약을 가로채서 서버로 몇번이고 재전송할 수 있기 때문에 안전하지 않다.

재전송 공격을 방지하기 위해 서버는 클라에게 난스라고 불리는 자주 바뀌는 (대략 1ms마다, 혹은 인증할 때마다) 증표를 건네준다.

난스를 비밀번호에 섞으면 난스가 바뀔 때마다 요약도 바뀌게 만들어준다. 저장된 비밀번호 요약은 특정 난스값에 대해서만 유효하고, 비밀번호 없이 공격자가 올바른 요약을 계산하는 것은 가능하지 않기 때문이다. 

다이제스트 인증은 난스를 사용할 것을 요구한다.
난스는 WWW-Authenticate 인증요구에 담겨서 서버에서 클라로 넘겨진다.