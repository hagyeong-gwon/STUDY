캐시
=

웹 캐시는 자주 쓰이는 문서의 사본을 자동으로 보관하는 HTTP 장치이다. 

웹 요청이 캐시에 도착했을 때, 캐시된 로컬 사본이 존재한다면, 그 문서는 원 서버가 아니라 그 캐시로부터 제공된다. 

- 불필요한 데이터 전송을 줄여서, 네트워크 요금으로 인한 비용을 줄여준다. 

- 캐시는 네트워크 병목을 줄여준다. 대역폭을 늘리지 않고도 페이지를 빨리 불러올 수 있게 된다.

- 캐시는 원 서버에 대한 요청을 줄여준다. 서버는 부하를 줄일 수 있으며 더 빨리 응답할 수 있게 된다.

- 페이지를 먼 곳에서 불러올수록 시간이 많이 걸리는데, 캐시는 거리로 인한 지연을 줄여준다. 

### 1. 불필요한 데이터 전송

복수의 클라이언트가 자주 쓰이는 원 서버 페이지에 접근할 때, 서버는 같은 문서를 클라이언트에게 각각 한 번씩 전송하게 된다. 

불필요한 데이터 전송은 값비싼 네트워크 대역폭을 잡아먹고, 전송을 느리게 만들며, 웹 서버에 부하를 준다. 

캐시를 이용하면, 첫 번째 서버응답은 캐시에 보관된다. 캐시된 사본이 뒤이은 요청들에 대한 응답으로 사용될 수 있기 때문에 원 서버가 중복해서 트래픽을 주고받는 낭비가 줄어들게 된다.

### 2. 대역폭 병목

많은 네트워크가 원격 서버보다 로컬 네트워크 클라이언트에 더 넓은 대역폭을 제공한다. 클라이언트들이 서버에 접근할 떄의 속도는, 그 경로에 있는 가장 느린 네트워크의 속도와 같다. 만약 클라이언트가 빠른 LAN에 있는는 캐시로부터 사본을 가져온다면, 캐싱은 성능을 대폭 개선할 수 있을 것이다.

### 3. 갑작스런 요청 쇄도

갑작스런 사건 속보, 스팸 메일, 유명 인사와 관련된 사건 등으로 인해 많은 사람이 거의 동시에 웹 문서에 접근할 때 초래된 불필요한 트래픽 급증은 네트워크와 웹 서버의 심각한 장애를 야기시킨다. 

### 4. 거리로 인한 지연

대역폭이 문제가 되지 않더라도, 거리가 문제가 될 수 있다. 모든 네트워크 라우터는 제각각 인터넷 트래픽을 지연시킨다. 보통 수준으로 복잡한 웹페이지들은 빛의 속도로 인한 지연이 수 초에 달할 수도 있다.

하지만 캐시를 설치해서 문서가 전송되는 거리를 수천 킬로미터에서 수십 미터로 줄일 수 있다.

### 5. 적중과 부적중

캐시에 요청이 도착했을 때, 만약 그에 대응하는 사본이 있다면 그를 이용해 요청이 처리될 수 있다. 이걸을 캐시 적중이라고 부른다.

만약 대응하는 사본이 없다면 그냥 원 서버로 전달되기만 할 뿐이다. 이것을 캐시 부적중이라고 부른다.

재검사

- 원 서버 콘텐츠는 변경될 수 있기 때문에, 캐시는 반드시 그들이 갖고 있는 사본이 최신인지 점검해야한다.(신선도 검사)

- 원서버에 작은 재검사 요청을 보낸다. 콘텐츠가 변경되지 않았다면 서버는 304 NOT MODIFIED 응답을 보낸다. 이를 재검사 적중 혹은 느린 적중이라고 부른다.

![image](https://user-images.githubusercontent.com/70934609/108762394-64664b80-7593-11eb-8a89-f6b33697d07b.png)


*캐시가 요청을 처리하는 비율을 캐시 적중률 혹은 문서 적중률이라고 부른다.*

### 6. 캐시 토폴로지

개인 전용 캐시

- 개인 전용 캐시는 많은 에너지나 저장 공가능ㄹ 필요로 하지 않으므로, 작고 저렴할 수 있다. 

- 공유 캐시는 프락시 캐시라고 불리는 특별한 종류의 공유된 프락시 서버이다. 프락시 캐시는 로컬 캐시에서 문서를 제공하거나, 혹은 사용자의 입장에서 서버에 접근한다. 공용 캐시에는 여러 사용자가 접근하기 때문에, 불필요한 트래픽을 줄일 수 있는 더 많은 기회가 있다.

![image](https://user-images.githubusercontent.com/70934609/108763349-9cba5980-7594-11eb-82ab-67768277c870.png)


### 7. 캐시 처리 단계

1. 요청 받기 : 캐시는 네트워크로부터 도착한 요청 메시지를 읽는다. 

2. 파싱 : 캐시는 메시지를 파싱하여 URL과 헤더를 추출한다.

3. 검색 : 캐시는 로컬 복사본이 있는지 검사하고, 사본이 없다면 사본을 받아온다.

4. 신선도 검사 : 캐시는 캐시된 사본이 충분히 신선한지 검사하고, 신선하지 않다면 변경사항이 있는지 서버에게 물어본다.

5. 응답 생성 :  캐시는 새로운 헤더와 캐시된 본문으로 응답 메시지를 만든다.

6. 발송 : 캐시는 네트워크를 통해 응답을 클라이언트에게 돌려준다.

7. 로깅 : 선택적으로, 캐시는 로그 파일에 트랜잭션에 대해 서술한 로그 하나를 남긴다.

![image](https://user-images.githubusercontent.com/70934609/108763969-5b767980-7595-11eb-8487-e836d4d54ced.png)


### 8. 신선하게 유지하기

HTTP는 Cache-Control과 Expires라는 특별한 헤더들을 이용해서 원 서버가 각 문서에 유효기간을 붙일 수 있게 해준다. 이 헤더들은 콘텐츠가 얼마나 오랫동안 신선한 상태로 보일 수 있는지 좌우한다.

- Cache-Control: max-age

max-age값은 문서의 최대 나이를 정의한다. 최대 나이는 문서가 처음 생성된 이후부터, 제공하기엔 더 이상 신선하지 않다고 간주될 때까지 경과한 시간의 합법적인 최댓값(초단위)이다.

```
Cache-Control: max-age: 484200
```

- Expires

절대 유효기간을 명시한다. 만약 유효기간이 경과했다면, 그 문서는 더 이상 신선하지 않다.

```
Expires: Fri, 05 Jul 2002, 05:00:00 GMT
```

### 조건부 메서드와 재검사

HTTP의 조건부 메서드는 재검사를 효율적으로 만들어준다.
HTTP는 캐시가 서버에게 조건부 GET이라는 요청을 보낼 수 있도록 해준다.

- 이 요청은 서버가 갖고 있는 문서가 캐시가 갖고 있는 것과 다를 경우에만
객체 본문을 보내달라고 하는 것이다.
- 신선도 검사와 객체를 받아오는 것은 하나의 조건부 GET으로 결합된다.
- 조건부 GET은 GET 요청 메세지에 특별한 조건부 헤더를 추가함으로써 시작된다

1. If-Modified-Since: 날짜 재검사

만약 문서가 주어진 날짜 이후에 변경되었다면 If-Modified-Since 조건은 참이므로 GET 요청은 평범하게 성공한다. 새 문서가, 새로운 만료 날짜와 그 외 다른 정보들이 담긴 헤더들과 함께 캐시에게 반환된다.

변경되지 않았다면 조건은 거짓이고, 서버는 304와 함께 응답메시지를 클라이언트에게 돌려준다.

**If-Modified-Since 헤더는 서버 응답 헤더의 Last-Modified 헤더와 함꼐 동작한다.**

```
If-Modified-Since: <캐시 된 마지막 수정일>
```

*If-None-Match와 함께 사용 시 무시된다.*

2. If-None-Match: 엔터티 태그 재검사


```
조건부 요청
GET /index.html HTTP/1.0
If-None-Match: "v2.6"
```

```
응답
HTTP/1.0 304 Not Modified
Date: Wed, 03 Jul 2002, 19:18:23 GMT
ETag: "v2.6"
Expires: Fri, 05 Jul 2002, 05:00:00 GMT
```

![image](https://user-images.githubusercontent.com/70934609/108765711-7a760b00-7597-11eb-84c1-2b1e7b4d94be.png)


### 9. 캐시 제어

아래는 HTTP는 문서가 얼마나 오랫동안 캐시될 수 있게 할 것인지,
서버가 설정할 수 있는 여러 가지 방법이다.

1. Cache-control: no-cache -  로컬 캐시 저장소에 저장될 수 있다. 다만, 먼저 서버와 재검사를 하지 않고서는 캐시에서 클라로 제공될 수 없을 뿐이다.

2. Cache-control: no-store - 캐시가 그 응답의 사본을 만드는 것을 금지한다.

3. Cache-control: must-revalidate

4. Cache-Control: max-age=<seconds> - 신선하다고 간주되었던 문서가 서버로부터 온 이후로 흐른 시간

5. Cache-control: s-maxage=<seconds> - 헤더는 공유된 캐시에만 적용된다.

6. Expires 날짜 헤더를 응답에 첨부할 수 있다. - 더 이상 사용하지 않기를 권하는 Expires 헤더는 실제 만료 날짜를 명시한다.

HTTP 설계자들은 많은 서버가 동기화되어있지 않거나
부정확한 시계를 갖고 있기 때문에,
만료를 절대 시각 대신 경과된 시간으로 표현하는 것이 낫다고 판단했다.

7. 아무 만료 정보도 주지 않고,
캐시가 스스로 체험적인(휴리스틱 heuristic) 방법으로 결정하게 할 수 있다.